"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
const expo_constants_1 = __importDefault(require("expo-constants"));
const url_parse_1 = __importDefault(require("url-parse"));
const Location_1 = require("./Location");
const getDevServer_1 = __importDefault(require("../getDevServer"));
let hasWarned = false;
// Add a development warning for fetch requests with relative paths
// to ensure developers are aware of the need to configure a production
// base URL in the Expo config (app.json) under `expo.extra.router.origin`.
function warnProductionOriginNotConfigured(requestUrl) {
    var _a, _b, _c;
    if (hasWarned) {
        return;
    }
    hasWarned = true;
    if (!((_c = (_b = (_a = expo_constants_1.default.manifest) === null || _a === void 0 ? void 0 : _a.extra) === null || _b === void 0 ? void 0 : _b.router) === null || _c === void 0 ? void 0 : _c.origin)) {
        console.warn(`The relative fetch request "${requestUrl}" will not work in production until the Expo config (app.json) \`expo.extra.router.origin\` field is set to the base URL of your web server. [Learn more](https://expo.github.io/router/docs/lab/runtime-location)`);
    }
}
// TODO: This would be better if native and tied as close to the JS engine as possible, i.e. it should
// reflect the exact location of the JS file that was executed.
function getBaseUrl() {
    var _a, _b, _c;
    // TODO: Make it official by moving out of `extra`
    let productionBaseUrl = (_c = (_b = (_a = expo_constants_1.default.manifest) === null || _a === void 0 ? void 0 : _a.extra) === null || _b === void 0 ? void 0 : _b.router) === null || _c === void 0 ? void 0 : _c.origin;
    if (!productionBaseUrl) {
        return null;
    }
    if (process.env.NODE_ENV !== "production") {
        // e.g. http://localhost:19006
        productionBaseUrl = (0, getDevServer_1.default)().url;
    }
    // Ensure no trailing slash
    return productionBaseUrl === null || productionBaseUrl === void 0 ? void 0 : productionBaseUrl.replace(/\/$/, "");
}
function wrapFetchWithWindowLocation(fetch) {
    if (fetch.__EXPO_BASE_URL_POLYFILLED) {
        return fetch;
    }
    const _fetch = (...props) => {
        var _a, _b;
        if (props[0] && typeof props[0] === "string" && props[0].startsWith("/")) {
            if (process.env.NODE_ENV !== "production") {
                warnProductionOriginNotConfigured(props[0]);
            }
            props[0] = new url_parse_1.default(props[0], (_a = window.location) === null || _a === void 0 ? void 0 : _a.origin).toString();
        }
        else if (props[0] && typeof props[0] === "object") {
            if (props[0].url &&
                typeof props[0].url === "string" &&
                props[0].url.startsWith("/")) {
                if (process.env.NODE_ENV !== "production") {
                    warnProductionOriginNotConfigured(props[0]);
                }
                props[0].url = new url_parse_1.default(props[0].url, (_b = window.location) === null || _b === void 0 ? void 0 : _b.origin).toString();
            }
        }
        return fetch(...props);
    };
    _fetch.__EXPO_BASE_URL_POLYFILLED = true;
    return _fetch;
}
if (((_c = (_b = (_a = expo_constants_1.default.manifest) === null || _a === void 0 ? void 0 : _a.extra) === null || _b === void 0 ? void 0 : _b.router) === null || _c === void 0 ? void 0 : _c.origin) !== false) {
    // Polyfill window.location in native runtimes.
    if (typeof window !== "undefined" && !window.location) {
        const url = getBaseUrl();
        if (url) {
            (0, Location_1.setLocationHref)(url);
            (0, Location_1.install)();
        }
    }
    // Polyfill native fetch to support relative URLs
    Object.defineProperty(global, "fetch", {
        value: wrapFetchWithWindowLocation(fetch),
    });
}
//# sourceMappingURL=install.native.js.map